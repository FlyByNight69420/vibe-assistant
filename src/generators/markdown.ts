import type { PRDDocument, Phase, ProgressState } from '../types.js';

export function generateMainPRD(prd: PRDDocument): string {
  return `# ${prd.projectInfo.name} - Product Requirements Document

> Generated by vibe-assistant using RPG (Repository Planning Graph) methodology

## 1. Overview

### Problem Statement
${prd.overview.problemStatement}

### Target Users
${prd.overview.targetUsers}

### Success Metrics
${prd.overview.successMetrics.map((m) => `- ${m}`).join('\n')}

---

## 2. Functional Decomposition

${prd.functionalDecomposition.map((domain) => `
### ${domain.name}
${domain.description}

${domain.features.map((feature) => `
#### ${feature.name}
${feature.description}

- **Inputs:** ${feature.inputs.join(', ')}
- **Outputs:** ${feature.outputs.join(', ')}
- **Behavior:** ${feature.behavior}
`).join('\n')}`).join('\n')}

---

## 3. Structural Decomposition

| Module | Path | Description | Capabilities | Dependencies |
|--------|------|-------------|--------------|--------------|
${prd.structuralDecomposition.map((m) =>
  `| ${m.name} | \`${m.path}\` | ${m.description} | ${m.capabilities.join(', ')} | ${m.dependencies.join(', ') || 'None'} |`
).join('\n')}

---

## 4. Dependency Graph

${prd.dependencyGraph.map((layer) => `
### ${layer.name} Layer
- **Modules:** ${layer.modules.join(', ')}
- **Depends On:** ${layer.dependsOn.join(', ') || 'None (Foundation)'}`).join('\n')}

---

## 5. Implementation Roadmap

${prd.implementationRoadmap.map((phase) => `
### Phase ${phase.number}: ${phase.name}
${phase.description}

**Entry Criteria:**
${phase.entryCriteria.map((c) => `- ${c}`).join('\n')}

**Exit Criteria:**
${phase.exitCriteria.map((c) => `- ${c}`).join('\n')}

**Tasks:** See \`docs/prd/phases/phase-${phase.number}.md\` for detailed task breakdown.
`).join('\n')}

---

## 6. Test Strategy

### Unit Tests
${prd.testStrategy.unitTests.map((t) => `- ${t}`).join('\n')}

### Integration Tests
${prd.testStrategy.integrationTests.map((t) => `- ${t}`).join('\n')}

### End-to-End Tests
${prd.testStrategy.e2eTests.map((t) => `- ${t}`).join('\n')}

### Coverage Target
${prd.testStrategy.coverageTarget}%

### Critical Scenarios
${prd.testStrategy.criticalScenarios.map((s) => `- ${s}`).join('\n')}

---

## 7. Architecture

### Key Decisions
${prd.architecture.decisions.map((d) => `- ${d}`).join('\n')}

### Data Models
${prd.architecture.dataModels.map((m) => `- ${m}`).join('\n')}

### Tech Stack Rationale
${prd.architecture.techStackRationale}

---

## 8. Infrastructure & Deployment

### Overview
${prd.infrastructure.overview}

### Hosting
- **Platform:** ${prd.infrastructure.hosting.platform}
- **Services:** ${prd.infrastructure.hosting.services.join(', ')}
- **Regions:** ${prd.infrastructure.hosting.regions.join(', ')}

### Infrastructure as Code
${prd.infrastructure.iacFiles.length > 0 ? `
| File | Tool | Description |
|------|------|-------------|
${prd.infrastructure.iacFiles.map((f) => `| \`${f.path}\` | ${f.tool} | ${f.description} |`).join('\n')}
` : 'No IaC files specified.'}

### CI/CD Pipeline
${prd.infrastructure.cicdPipeline.description}

**Triggers:** ${prd.infrastructure.cicdPipeline.triggers.join(', ')}

**Steps:**
${prd.infrastructure.cicdPipeline.steps.map((s, i) => `${i + 1}. ${s}`).join('\n')}

**Artifacts:** ${prd.infrastructure.cicdPipeline.artifacts.join(', ')}

### Containerization
- **Dockerfile:** \`${prd.infrastructure.containerization.dockerfile}\`
${prd.infrastructure.containerization.composeFile ? `- **Compose File:** \`${prd.infrastructure.containerization.composeFile}\`` : ''}
- **Orchestration:** ${prd.infrastructure.containerization.orchestration}

### Environments
| Environment | Purpose | Auto-Deploy Branch | URL |
|-------------|---------|-------------------|-----|
${prd.infrastructure.environments.map((e) =>
  `| ${e.name} | ${e.purpose} | ${e.autoDeployBranch || '-'} | ${e.url || '-'} |`
).join('\n')}

### Secrets Management
**Strategy:** ${prd.infrastructure.secrets.strategy}

**Required Secrets:**
${prd.infrastructure.secrets.requiredSecrets.map((s) => `- \`${s}\``).join('\n')}

### Bootstrap (Zero to Running)
\`\`\`bash
${prd.infrastructure.bootstrapSteps.join('\n')}
\`\`\`

### Teardown
\`\`\`bash
${prd.infrastructure.teardownSteps.join('\n')}
\`\`\`

---

## 9. Risks

| Type | Description | Likelihood | Impact | Mitigation |
|------|-------------|------------|--------|------------|
${prd.risks.map((r) =>
  `| ${r.type} | ${r.description} | ${r.likelihood} | ${r.impact} | ${r.mitigation} |`
).join('\n')}

---

## 10. Appendix

### Glossary
${Object.entries(prd.appendix.glossary).map(([term, def]) => `- **${term}:** ${def}`).join('\n')}

### Open Questions
${prd.appendix.openQuestions.map((q) => `- ${q}`).join('\n')}

### References
${prd.appendix.references.map((r) => `- ${r}`).join('\n')}

---

## Context Instructions for AI Agents

> **IMPORTANT:** This section contains instructions for AI coding agents working on this project.

### Before Starting Any Work
1. Read this entire PRD to understand the full scope
2. Check \`docs/progress/state.json\` for current progress
3. Read the relevant phase file in \`docs/prd/phases/\`

### During Implementation
1. Work through phases sequentially
2. Complete all tasks in a phase before moving to the next
3. After each task, run \`/checkpoint\` to save progress
4. If stuck, run \`/research <topic>\` for guidance

### Maintaining Context
1. Re-read relevant sections of this PRD when starting new tasks
2. Reference \`docs/progress/\` summaries for context on completed work
3. Keep task descriptions in sync with actual implementation

### File Structure
\`\`\`
docs/
├── prd/
│   ├── PRD.md (this file)
│   ├── phases/
│   │   ├── phase-1.md
│   │   └── ...
│   └── research/
└── progress/
    ├── state.json
    └── phase-*-summary.md
\`\`\`
`;
}

export function generatePhaseFile(phase: Phase, prd: PRDDocument): string {
  return `# Phase ${phase.number}: ${phase.name}

> Part of [${prd.projectInfo.name} PRD](../PRD.md)

## Overview
${phase.description}

## Entry Criteria
${phase.entryCriteria.map((c) => `- [ ] ${c}`).join('\n')}

## Exit Criteria
${phase.exitCriteria.map((c) => `- [ ] ${c}`).join('\n')}

---

## Tasks

${phase.tasks.map((task, index) => `
### ${index + 1}. ${task.title}
**ID:** \`${task.id}\`
**Status:** ${task.status}
**Parallelizable:** ${task.parallelizable ? 'Yes' : 'No'}
**Dependencies:** ${task.dependencies.length > 0 ? task.dependencies.map((d) => `\`${d}\``).join(', ') : 'None'}

${task.description}

${task.researchRequired ? `
> **Research Required:** ${task.researchRequired}
> Run \`/research ${task.researchRequired}\` before starting this task.
` : ''}`).join('\n---\n')}

---

## Completion Checklist

When all tasks are complete:
1. [ ] All exit criteria met
2. [ ] Tests passing for this phase
3. [ ] Run \`/checkpoint\` to update progress
4. [ ] Proceed to Phase ${phase.number + 1} (if applicable)
`;
}

export function generateInitialState(prd: PRDDocument): ProgressState {
  const tasks: ProgressState['tasks'] = {};

  for (const phase of prd.implementationRoadmap) {
    for (const task of phase.tasks) {
      tasks[task.id] = { status: 'pending' };
    }
  }

  return {
    currentPhase: 1,
    tasks,
    checkpoints: [],
    lastUpdated: new Date().toISOString(),
  };
}
